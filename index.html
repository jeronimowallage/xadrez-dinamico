<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xadrez Completo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Tela Inicial */
        .start-screen {
            text-align: center;
            padding: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            max-width: 600px;
            margin: 0 auto;
            animation: fadeIn 0.8s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .logo {
            font-size: 4.5rem;
            margin-bottom: 20px;
            font-weight: 800;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45aaf2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 30px;
            color: #d8d8d8;
        }

        .game-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 30px;
        }

        .btn {
            padding: 16px 32px;
            border: none;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #6a11cb, #2575fc);
            color: white;
            box-shadow: 0 4px 15px rgba(106, 17, 203, 0.4);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
            pointer-events: none;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(106, 17, 203, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .difficulty-options {
            display: none;
            flex-direction: column;
            gap: 12px;
            margin-top: 20px;
            animation: slideDown 0.5s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Jogo */
        .game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            width: 100%;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            padding: 15px 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            font-size: 1.2rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .chess-board-container {
            width: 500px;
            height: 500px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: #7a5230;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        .light {
            background-color: #f0d9b5;
        }

        .dark {
            background-color: #b58863;
        }

        .selected {
            background-color: rgba(76, 175, 80, 0.6);
        }

        .possible-move {
            position: relative;
        }

        .possible-move::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            background-color: rgba(76, 175, 80, 0.6);
            border-radius: 50%;
            z-index: 1;
        }

        .capture-move::after {
            content: '';
            position: absolute;
            width: 85%;
            height: 85%;
            border: 4px solid rgba(76, 175, 80, 0.6);
            border-radius: 50%;
            z-index: 1;
        }

        .check {
            background-color: rgba(255, 0, 0, 0.4) !important;
        }

        .coordinates {
            position: absolute;
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(0, 0, 0, 0.6);
            z-index: 2;
        }

        .file-coord {
            bottom: 4px;
            right: 6px;
        }

        .rank-coord {
            top: 4px;
            left: 6px;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .piece {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            z-index: 3;
            font-size: 2.8rem;
        }

        .white-piece {
            color: #ffffff;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        .black-piece {
            color: #000000;
            text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.3);
        }

        .game-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            display: none;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
        }

        .promotion-options {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 15px;
            z-index: 101;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            text-align: center;
        }

        .promotion-options h3 {
            margin-bottom: 20px;
            color: white;
        }

        .promotion-piece {
            font-size: 3rem;
            margin: 10px;
            padding: 10px;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .promotion-piece:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.2);
        }

        /* Responsividade */
        @media (max-width: 600px) {
            .logo {
                font-size: 3.5rem;
            }
            
            .btn {
                padding: 14px 25px;
                font-size: 1.1rem;
            }
            
            .status-bar {
                flex-direction: column;
                align-items: center;
                gap: 10px;
                text-align: center;
            }
            
            .chess-board-container {
                width: 350px;
                height: 350px;
            }
            
            .piece {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }

            .promotion-piece {
                font-size: 2.5rem;
                margin: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Tela Inicial -->
        <div class="start-screen" id="startScreen">
            <div class="logo">XADREZ</div>
            <p class="subtitle">O jogo de estratégia milenar</p>
            
            <div class="game-options">
                <button class="btn" id="pvpBtn">Jogador vs Jogador</button>
                <button class="btn" id="pvcBtn">Jogador vs Computador</button>
                
                <div class="difficulty-options" id="difficultyOptions">
                    <button class="btn difficulty-btn" data-difficulty="easy">Fácil</button>
                    <button class="btn difficulty-btn" data-difficulty="medium">Médio</button>
                    <button class="btn difficulty-btn" data-difficulty="hard">Difícil</button>
                </div>
            </div>
        </div>
        
        <!-- Jogo -->
        <div class="game-container" id="gameContainer">
            <div class="status-bar">
                <div id="turnIndicator">Turno: Brancas</div>
                <div id="gameStatus"></div>
            </div>
            
            <div class="chess-board-container">
                <div class="chess-board" id="chessBoard"></div>
            </div>
            
            <div class="controls">
                <button class="btn" id="restartBtn">Reiniciar</button>
                <button class="btn" id="menuBtn">Voltar ao Menu</button>
            </div>
        </div>

        <div class="game-message" id="gameMessage">
            <h2 id="messageTitle"></h2>
            <p id="messageText"></p>
            <button class="btn" id="messageBtn">OK</button>
        </div>

        <div class="promotion-options" id="promotionOptions">
            <h3>Escolha uma peça para promoção:</h3>
            <div class="promotion-pieces">
                <div class="promotion-piece" data-piece="queen">♕</div>
                <div class="promotion-piece" data-piece="rook">♖</div>
                <div class="promotion-piece" data-piece="bishop">♗</div>
                <div class="promotion-piece" data-piece="knight">♘</div>
            </div>
        </div>
    </div>

    <script>
        // Variáveis globais
        let board = [];
        let selectedPiece = null;
        let currentPlayer = 'white';
        let gameMode = 'pvp';
        let difficulty = 'medium';
        let gameStatus = 'playing';
        let checkState = { white: false, black: false };
        let pendingPromotion = null; // {row, col, color}

        // Inicialização do jogo
        document.addEventListener('DOMContentLoaded', () => {
            initializeStartScreen();
            initializeBoard();
            setupEventListeners();
        });

        // Configurar event listeners
        function setupEventListeners() {
            document.getElementById('restartBtn').addEventListener('click', resetGame);
            document.getElementById('menuBtn').addEventListener('click', () => {
                document.getElementById('gameContainer').style.display = 'none';
                document.getElementById('startScreen').style.display = 'block';
                document.getElementById('difficultyOptions').style.display = 'none';
            });
            
            document.getElementById('messageBtn').addEventListener('click', () => {
                document.getElementById('gameMessage').style.display = 'none';
            });
            
            // Event listeners para promoção de peão
            const promotionPieces = document.querySelectorAll('.promotion-piece');
            promotionPieces.forEach(piece => {
                piece.addEventListener('click', () => {
                    handlePromotionSelection(piece.getAttribute('data-piece'));
                });
            });
        }

        // Configuração da tela inicial
        function initializeStartScreen() {
            const pvpBtn = document.getElementById('pvpBtn');
            const pvcBtn = document.getElementById('pvcBtn');
            const difficultyOptions = document.getElementById('difficultyOptions');
            const difficultyBtns = document.querySelectorAll('.difficulty-btn');
            
            pvpBtn.addEventListener('click', () => {
                gameMode = 'pvp';
                startGame();
            });
            
            pvcBtn.addEventListener('click', () => {
                difficultyOptions.style.display = 'flex';
            });
            
            difficultyBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    gameMode = 'pvc';
                    difficulty = btn.getAttribute('data-difficulty');
                    startGame();
                });
            });
        }

        // Iniciar o jogo
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'flex';
            resetGame();
            renderBoard();
        }

        // Configuração do tabuleiro
        function initializeBoard() {
            const chessBoard = document.getElementById('chessBoard');
            chessBoard.innerHTML = '';
            
            // Criar tabuleiro 8x8
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.setAttribute('data-row', row);
                    square.setAttribute('data-col', col);
                    
                    // Adicionar coordenadas para as bordas
                    if (row === 7) {
                        const fileCoord = document.createElement('div');
                        fileCoord.classList.add('coordinates', 'file-coord');
                        fileCoord.textContent = String.fromCharCode(97 + col);
                        square.appendChild(fileCoord);
                    }
                    
                    if (col === 0) {
                        const rankCoord = document.createElement('div');
                        rankCoord.classList.add('coordinates', 'rank-coord');
                        rankCoord.textContent = 8 - row;
                        square.appendChild(rankCoord);
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    chessBoard.appendChild(square);
                }
            }
        }

        // Reiniciar o jogo
        function resetGame() {
            // Configuração inicial do tabuleiro
            board = [
                [
                    { type: 'rook', color: 'black' },
                    { type: 'knight', color: 'black' },
                    { type: 'bishop', color: 'black' },
                    { type: 'queen', color: 'black' },
                    { type: 'king', color: 'black' },
                    { type: 'bishop', color: 'black' },
                    { type: 'knight', color: 'black' },
                    { type: 'rook', color: 'black' }
                ],
                Array(8).fill(null).map(() => ({ type: 'pawn', color: 'black' })),
                Array(8).fill(null),
                Array(8).fill(null),
                Array(8).fill(null),
                Array(8).fill(null),
                Array(8).fill(null).map(() => ({ type: 'pawn', color: 'white' })),
                [
                    { type: 'rook', color: 'white' },
                    { type: 'knight', color: 'white' },
                    { type: 'bishop', color: 'white' },
                    { type: 'queen', color: 'white' },
                    { type: 'king', color: 'white' },
                    { type: 'bishop', color: 'white' },
                    { type: 'knight', color: 'white' },
                    { type: 'rook', color: 'white' }
                ]
            ];
            
            selectedPiece = null;
            currentPlayer = 'white';
            gameStatus = 'playing';
            checkState = { white: false, black: false };
            pendingPromotion = null;
            
            document.getElementById('turnIndicator').textContent = 'Turno: Brancas';
            document.getElementById('gameStatus').textContent = '';
            
            renderBoard();
        }

        // Renderizar o tabuleiro
        function renderBoard() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                    const piece = board[row][col];
                    
                    // Limpar quadrado
                    square.innerHTML = '';
                    
                    // Adicionar coordenadas se necessário
                    if (row === 7) {
                        const fileCoord = document.createElement('div');
                        fileCoord.classList.add('coordinates', 'file-coord');
                        fileCoord.textContent = String.fromCharCode(97 + col);
                        square.appendChild(fileCoord);
                    }
                    
                    if (col === 0) {
                        const rankCoord = document.createElement('div');
                        rankCoord.classList.add('coordinates', 'rank-coord');
                        rankCoord.textContent = 8 - row;
                        square.appendChild(rankCoord);
                    }
                    
                    // Adicionar peça se existir
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.textContent = getPieceSymbol(piece.type, piece.color);
                        pieceElement.classList.add('piece', `${piece.color}-piece`);
                        square.appendChild(pieceElement);
                    }
                    
                    // Remover classes de destaque
                    square.classList.remove('selected', 'possible-move', 'capture-move', 'check');
                }
            }
            
            // Destacar rei em xeque se aplicável
            if (checkState.white || checkState.black) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.type === 'king') {
                            if (checkState[piece.color]) {
                                const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                                square.classList.add('check');
                            }
                        }
                    }
                }
            }
            
            // Atualizar status do jogo
            updateGameStatus();
        }

        // Obter símbolo Unicode para a peça
        function getPieceSymbol(pieceType, pieceColor) {
            const symbols = {
                white: {
                    king: '♔',
                    queen: '♕',
                    rook: '♖',
                    bishop: '♗',
                    knight: '♘',
                    pawn: '♙'
                },
                black: {
                    king: '♚',
                    queen: '♛',
                    rook: '♜',
                    bishop: '♝',
                    knight: '♞',
                    pawn: '♟'
                }
            };
            return symbols[pieceColor][pieceType];
        }

        // Manipular clique no quadrado
        function handleSquareClick(row, col) {
            if (gameStatus !== 'playing') return;
            
            // Se houver uma promoção pendente, ignore outros cliques
            if (pendingPromotion) return;
            
            // Verificar se é a vez do jogador atual (em modo PvC, o computador é preto)
            if (gameMode === 'pvc' && currentPlayer === 'black') return;
            
            const clickedPiece = board[row][col];
            const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
            
            // Se já temos uma peça selecionada, tentar mover
            if (selectedPiece) {
                const [selectedRow, selectedCol] = selectedPiece;
                
                // Verificar se o movimento é válido
                if (isValidMove(selectedRow, selectedCol, row, col)) {
                    // Mover a peça
                    const movingPiece = board[selectedRow][selectedCol];
                    board[row][col] = movingPiece;
                    board[selectedRow][selectedCol] = null;
                    
                    // Verificar promoção de peão
                    if (movingPiece.type === 'pawn' && (row === 0 || row === 7)) {
                        // Promoção de peão - mostrar opções
                        pendingPromotion = { row, col, color: movingPiece.color };
                        showPromotionOptions(movingPiece.color);
                    } else {
                        // Alternar jogador
                        currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                        document.getElementById('turnIndicator').textContent = `Turno: ${currentPlayer === 'white' ? 'Brancas' : 'Negras'}`;
                        
                        // Verificar xeque e xeque-mate
                        checkForCheckAndMate();
                        
                        // Se for modo jogador vs computador e for a vez do computador
                        if (gameMode === 'pvc' && currentPlayer === 'black') {
                            setTimeout(makeComputerMove, 600);
                        }
                    }
                }
                
                // Desselecionar peça independentemente do movimento ser válido ou não
                clearSelection();
                renderBoard();
                return;
            }
            
            // Selecionar peça se for do jogador atual
            if (clickedPiece && clickedPiece.color === currentPlayer) {
                selectedPiece = [row, col];
                square.classList.add('selected');
                
                // Destacar movimentos possíveis
                highlightPossibleMoves(row, col);
            }
        }

        // Mostrar opções de promoção
        function showPromotionOptions(color) {
            const promotionOptions = document.getElementById('promotionOptions');
            const promotionPieces = promotionOptions.querySelectorAll('.promotion-piece');
            
            // Ajustar cores das peças de acordo com a cor do jogador
            promotionPieces.forEach(piece => {
                piece.style.color = color === 'white' ? '#fff' : '#000';
            });
            
            promotionOptions.style.display = 'block';
        }

        // Manipular seleção de promoção
        function handlePromotionSelection(pieceType) {
            if (!pendingPromotion) return;
            
            const { row, col, color } = pendingPromotion;
            
            // Promover o peão para a peça selecionada
            board[row][col] = { type: pieceType, color: color };
            
            // Esconder opções de promoção
            document.getElementById('promotionOptions').style.display = 'none';
            pendingPromotion = null;
            
            // Alternar jogador
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            document.getElementById('turnIndicator').textContent = `Turno: ${currentPlayer === 'white' ? 'Brancas' : 'Negras'}`;
            
            // Verificar xeque e xeque-mate
            checkForCheckAndMate();
            
            // Se for modo jogador vs computador e for a vez do computador
            if (gameMode === 'pvc' && currentPlayer === 'black') {
                setTimeout(makeComputerMove, 600);
            }
            
            renderBoard();
        }

        // Limpar seleção
        function clearSelection() {
            selectedPiece = null;
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                square.classList.remove('selected', 'possible-move', 'capture-move');
            });
        }

        // Destacar movimentos possíveis
        function highlightPossibleMoves(row, col) {
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (isValidMove(row, col, i, j)) {
                        const square = document.querySelector(`.square[data-row="${i}"][data-col="${j}"]`);
                        if (board[i][j]) {
                            square.classList.add('capture-move');
                        } else {
                            square.classList.add('possible-move');
                        }
                    }
                }
            }
        }

        // Verificar se o movimento é válido
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return false;
            
            // Não pode mover para a mesma posição
            if (fromRow === toRow && fromCol === toCol) return false;
            
            // Não pode capturar peça do mesmo time
            const targetPiece = board[toRow][toCol];
            if (targetPiece && targetPiece.color === piece.color) return false;
            
            // Verificar movimento específico da peça
            let isValid = false;
            
            switch (piece.type) {
                case 'pawn':
                    isValid = isValidPawnMove(fromRow, fromCol, toRow, toCol, piece.color);
                    break;
                case 'rook':
                    isValid = isValidRookMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'knight':
                    isValid = isValidKnightMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'bishop':
                    isValid = isValidBishopMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'queen':
                    isValid = isValidQueenMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'king':
                    isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                    break;
            }
            
            // Se o movimento for válido pelas regras da peça, verificar se não deixa o rei em xeque
            if (isValid) {
                // Simular movimento
                const originalBoard = JSON.parse(JSON.stringify(board));
                const movedPiece = board[fromRow][fromCol];
                board[toRow][toCol] = movedPiece;
                board[fromRow][fromCol] = null;
                
                // Verificar se o rei ficaria em xeque
                const kingPos = findKing(movedPiece.color);
                if (isSquareAttacked(kingPos[0], kingPos[1], movedPiece.color === 'white' ? 'black' : 'white')) {
                    isValid = false;
                }
                
                // Restaurar tabuleiro
                board = originalBoard;
            }
            
            return isValid;
        }

        // Movimentos específicos para cada peça
        function isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            
            // Movimento para frente
            if (fromCol === toCol) {
                // Movimento de uma casa
                if (toRow === fromRow + direction && !board[toRow][toCol]) {
                    return true;
                }
                
                // Movimento de duas casas na primeira jogada
                if (fromRow === startRow && toRow === fromRow + 2 * direction && 
                    !board[fromRow + direction][fromCol] && !board[toRow][toCol]) {
                    return true;
                }
            }
            
            // Captura na diagonal
            if (toRow === fromRow + direction && Math.abs(toCol - fromCol) === 1) {
                if (board[toRow][toCol] && board[toRow][toCol].color !== color) {
                    return true;
                }
            }
            
            return false;
        }

        function isValidRookMove(fromRow, fromCol, toRow, toCol) {
            // Movimento deve ser na mesma linha ou mesma coluna
            if (fromRow !== toRow && fromCol !== toCol) return false;
            
            // Verificar se não há peças no caminho
            if (fromRow === toRow) {
                const start = Math.min(fromCol, toCol) + 1;
                const end = Math.max(fromCol, toCol);
                for (let col = start; col < end; col++) {
                    if (board[fromRow][col]) return false;
                }
            } else {
                const start = Math.min(fromRow, toRow) + 1;
                const end = Math.max(fromRow, toRow);
                for (let row = start; row < end; row++) {
                    if (board[row][fromCol]) return false;
                }
            }
            
            return true;
        }

        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }

        function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
            // Movimento deve ser diagonal
            if (Math.abs(toRow - fromRow) !== Math.abs(toCol - fromCol)) return false;
            
            // Verificar se não há peças no caminho
            const rowDirection = toRow > fromRow ? 1 : -1;
            const colDirection = toCol > fromCol ? 1 : -1;
            
            let row = fromRow + rowDirection;
            let col = fromCol + colDirection;
            
            while (row !== toRow && col !== toCol) {
                if (board[row][col]) return false;
                row += rowDirection;
                col += colDirection;
            }
            
            return true;
        }

        function isValidQueenMove(fromRow, fromCol, toRow, toCol) {
            return isValidRookMove(fromRow, fromCol, toRow, toCol) || 
                   isValidBishopMove(fromRow, fromCol, toRow, toCol);
        }

        function isValidKingMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            return rowDiff <= 1 && colDiff <= 1;
        }

        // Encontrar a posição do rei
        function findKing(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type === 'king' && piece.color === color) {
                        return [row, col];
                    }
                }
            }
            return null;
        }

        // Verificar se uma casa está sob ataque
        function isSquareAttacked(row, col, byColor) {
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece && piece.color === byColor) {
                        // Verificar se esta peça pode atacar a casa (row, col)
                        if (isValidMoveWithoutCheck(i, j, row, col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Versão simplificada da verificação de movimento (sem verificar xeque)
        function isValidMoveWithoutCheck(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return false;
            
            // Não pode mover para a mesma posição
            if (fromRow === toRow && fromCol === toCol) return false;
            
            // Não pode capturar peça do mesmo time
            const targetPiece = board[toRow][toCol];
            if (targetPiece && targetPiece.color === piece.color) return false;
            
            // Verificar movimento específico da peça
            switch (piece.type) {
                case 'pawn':
                    return isValidPawnMove(fromRow, fromCol, toRow, toCol, piece.color);
                case 'rook':
                    return isValidRookMove(fromRow, fromCol, toRow, toCol);
                case 'knight':
                    return isValidKnightMove(fromRow, fromCol, toRow, toCol);
                case 'bishop':
                    return isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case 'queen':
                    return isValidQueenMove(fromRow, fromCol, toRow, toCol);
                case 'king':
                    return isValidKingMove(fromRow, fromCol, toRow, toCol);
                default:
                    return false;
            }
        }

        // Verificar xeque e xeque-mate
        function checkForCheckAndMate() {
            // Verificar xeque
            const whiteKingPos = findKing('white');
            const blackKingPos = findKing('black');
            
            checkState.white = isSquareAttacked(whiteKingPos[0], whiteKingPos[1], 'black');
            checkState.black = isSquareAttacked(blackKingPos[0], blackKingPos[1], 'white');
            
            // Verificar xeque-mate para o jogador atual
            const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
            if (isCheckmate(opponentColor)) {
                gameStatus = 'checkmate';
                showGameMessage("Xeque-mate!", `${currentPlayer === 'white' ? 'Brancas' : 'Negras'} vencem!`);
            } else if (checkState[opponentColor]) {
                document.getElementById('gameStatus').textContent = 
                    `${opponentColor === 'white' ? 'Brancas' : 'Negras'} estão em xeque!`;
            } else {
                document.getElementById('gameStatus').textContent = '';
            }
        }

        // Verificar xeque-mate
        function isCheckmate(color) {
            // Para todas as peças da cor
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && piece.color === color) {
                        // Para todos os movimentos possíveis desta peça
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    // Se algum movimento sair do xeque, não é mate
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
            
            // Nenhum movimento sai do xeque - é mate
            return true;
        }

        // Mostrar mensagem do jogo
        function showGameMessage(title, text) {
            document.getElementById('messageTitle').textContent = title;
            document.getElementById('messageText').textContent = text;
            document.getElementById('gameMessage').style.display = 'block';
        }

        // Atualizar status do jogo
        function updateGameStatus() {
            if (gameStatus === 'checkmate') {
                document.getElementById('gameStatus').textContent = 
                    `Xeque-mate! ${currentPlayer === 'white' ? 'Brancas' : 'Negras'} vencem!`;
            }
        }

        // Movimento do computador (IA) com suporte a promoção
        function makeComputerMove() {
            if (gameStatus !== 'playing' || currentPlayer !== 'black') return;
            
            // Coletar todos os movimentos possíveis
            const possibleMoves = [];
            
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && piece.color === 'black') {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    possibleMoves.push({
                                        from: [fromRow, fromCol],
                                        to: [toRow, toCol],
                                        score: evaluateMove(fromRow, fromCol, toRow, toCol)
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            // Escolher o melhor movimento baseado na dificuldade
            if (possibleMoves.length > 0) {
                let selectedMove;
                
                if (difficulty === 'easy') {
                    // Movimento aleatório
                    selectedMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                } else if (difficulty === 'medium') {
                    // Escolher um movimento razoavelmente bom
                    possibleMoves.sort((a, b) => b.score - a.score);
                    const bestMoves = possibleMoves.filter(move => move.score >= possibleMoves[0].score - 10);
                    selectedMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
                } else {
                    // Difícil - escolher o melhor movimento
                    possibleMoves.sort((a, b) => b.score - a.score);
                    selectedMove = possibleMoves[0];
                }
                
                // Executar o movimento
                const [fromRow, fromCol] = selectedMove.from;
                const [toRow, toCol] = selectedMove.to;
                
                const movingPiece = board[fromRow][fromCol];
                board[toRow][toCol] = movingPiece;
                board[fromRow][fromCol] = null;
                
                // Verificar promoção de peão (computador sempre escolhe rainha)
                if (movingPiece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                    board[toRow][toCol] = { type: 'queen', color: 'black' };
                }
                
                // Alternar jogador
                currentPlayer = 'white';
                document.getElementById('turnIndicator').textContent = 'Turno: Brancas';
                
                // Verificar xeque e xeque-mate
                checkForCheckAndMate();
                
                renderBoard();
            } else {
                // Se não há movimentos possíveis, é empate ou vitória do oponente
                if (checkState.black) {
                    gameStatus = 'checkmate';
                    showGameMessage("Xeque-mate!", "Brancas vencem!");
                } else {
                    showGameMessage("Empate!", "Não há movimentos possíveis!");
                }
            }
        }

        // Avaliar movimento para a IA
        function evaluateMove(fromRow, fromCol, toRow, toCol) {
            let score = 0;
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            
            // Sistema de pontuação para capturas
            if (targetPiece) {
                const pieceValues = {
                    pawn: 10,
                    knight: 30,
                    bishop: 30,
                    rook: 50,
                    queen: 90,
                    king: 900
                };
                score += pieceValues[targetPiece.type];
            }
            
            // Valor posicional - incentivar o centro
            const centerBonus = [
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 1, 2, 3, 3, 2, 1, 0],
                [0, 2, 4, 6, 6, 4, 2, 0],
                [0, 3, 6, 8, 8, 6, 3, 0],
                [0, 3, 6, 8, 8, 6, 3, 0],
                [0, 2, 4, 6, 6, 4, 2, 0],
                [0, 1, 2, 3, 3, 2, 1, 0],
                [0, 0, 0, 0, 0, 0, 0, 0]
            ];
            
            score += centerBonus[toRow][toCol];
            
            // Penalizar colocar a peça em uma casa atacada
            if (isSquareAttacked(toRow, toCol, 'white')) {
                const pieceValues = {
                    pawn: 10,
                    knight: 30,
                    bishop: 30,
                    rook: 50,
                    queen: 90,
                    king: 900
                };
                score -= pieceValues[piece.type] / 2;
            }
            
            // Bônus por dar xeque
            const simulatedBoard = JSON.parse(JSON.stringify(board));
            const movedPiece = board[fromRow][fromCol];
            board[toRow][toCol] = movedPiece;
            board[fromRow][fromCol] = null;
            
            const whiteKingPos = findKing('white');
            if (isSquareAttacked(whiteKingPos[0], whiteKingPos[1], 'black')) {
                score += 50;
            }
            
            // Restaurar tabuleiro
            board = simulatedBoard;
            
            return score;
        }
    </script>
</body>
</html>
